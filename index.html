<?xml version="1.0" encoding="UTF-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="viewport" content="width=device-width" />
<title>[@@sci8]</title>
<link rel="Stylesheet" type="text/css" href="./css.css" title="heritage" />
<script type="module" src="./js.js"></script>
</head>
<body xml:lang="ja">
<h1>日記</h1>
<!--
<article id="ID_TIME_STAMP_">
<section>
<h3></h3>
</section>
</article>
-->
<!--
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"></math>
-->
<article id="ID_TIME_STAMP_1661361550392">
<section>
<h3>実数の絶対値</h3>
<p>というか最初に習う時点においては有理数の絶対値を中学校で教わる。例外なくみんな符号を除去した数にすると勝手に解釈している。結果は正しい。何故なら文字式ではなく数値そのもので習うから。<br />
しかし文字式で大雑把に言うとたとえば<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>|</mo><mi>a</mi><mo>|</mo></mrow></math>ならば</p>
<ol><li>まず<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mrow><mo>-</mo><mi>a</mi></mrow></math>と<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mrow><mi>a</mi></mrow></math>を作って、</li>
<li>大小比較して小さくない方を採用する。</li></ol>
<p>という手順を踏む。この大小比較に際して絶対値の中身の正負で場合分けが不可避になる。ここで中学生にとっても重要なのは場合分けが<strong>2</strong>つということ。これは大人も含めてほぼ壊滅的に意識できていないが覚えておいて損は無い。これは高校卒業までに必ず遭遇するであろう方程式</p>
<ul><li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>|</mo><mi>x</mi><mo>|</mo></mrow><mo>+</mo><mrow><mo>|</mo><mi>y</mi><mo>|</mo></mrow><mo>=</mo><mn>1</mn></math> (菱形の<var>4</var>辺)</li>
<li><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mo>|</mo><mi>x</mi><mo>|</mo></mrow><mo>+</mo><mrow><mo>|</mo><mi>y</mi><mo>|</mo></mrow><mo>+</mo><mrow><mo>|</mo><mi>z</mi><mo>|</mo></mrow><mo>=</mo><mn>1</mn></math> (正八面体の<var>8</var>面)</li></ul>
<p>で気付く人は気付く。<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><msup><mn>2</mn><mn>2</mn></msup></math>辺ぶんと<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><msup><mn>2</mn><mn>3</mn></msup></math>面ぶんの個数になる方程式がまとめて書けて『便利じゃないわけじゃない』との認識を誰もが持つ。</p>
<p>臨機応変という言葉は極めて広い適用範囲で俗に使われるが、個人的には臨機応変に考えられる人は10万人に1人ほどしか実在しないと思っている。この場合分け2つの件にしたって、たとえば整数の配列があって、それをシャッフルした配列を作って、この2つの配列を同じインデックス順に引き算して絶対値を取って3つ目の配列を作ると</p>
<pre xml:lang="en"><samp>irb(main):001:0&gt; </samp><kbd>a = Array.new(10) {rand 10}
</kbd><samp>=&gt; [8, 5, 8, 9, 5, 4, 9, 3, 8, 7]
irb(main):002:0&gt; </samp><kbd>b = a.shuffle
</kbd><samp>=&gt; [5, 4, 8, 3, 9, 8, 8, 5, 7, 9]
irb(main):003:0&gt; </samp><kbd>c = [a, b].transpose.map {|a, b| (a - b).abs}
</kbd><samp>=&gt; [3, 1, 0, 6, 4, 4, 1, 2, 1, 2]
irb(main):004:0&gt; </samp><kbd>c.sum
</kbd><samp>=&gt; 24</samp></pre>
<p>のようにこの3つ目の配列の要素の総和は偶数になり一般にもそうなるわけだが、これを説明できる人は滅多にいない。絶対値を外す時の場合分けは高々2つなのだから最初の配列のある要素とシャッフル先のその要素を、絶対値を外した後に和の交換則で並べ替えて和の結合則で対応させてみると0倍か2倍か-2倍にしかなりえないわけだが、そこに考えが自力で至る人は実在するのかもしれないが現実には会ったことがない。<br />
しかし全ての中学生に場合分け2つという事実を天下り式に暗記させたら、もしかしたら絶対値を外す時に高々2つならば何とかなるんじゃないかと考えて前進できる人はもっともっと多くなるような気はする。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1661358001624">
<section>
<h3>2つのサイコロの目の合計が偶数の時</h3>
<p>とりあえず全て書き出すと</p>
<pre xml:lang="en"><samp>&gt;&gt;&gt; </samp><kbd>from itertools import product
</kbd><samp>&gt;&gt;&gt; </samp><kbd>[t for t in product([1, 2, 3, 4, 5, 6, ], repeat=2)]
</kbd><samp>[(1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6),
 (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6),
 (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6),
 (4, 1), (4, 2), (4, 3), (4, 4), (4, 5), (4, 6),
 (5, 1), (5, 2), (5, 3), (5, 4), (5, 5), (5, 6),
 (6, 1), (6, 2), (6, 3), (6, 4), (6, 5), (6, 6)]</samp></pre>
<p>要するに小学生に樹形図を書かせるのと同じ。<br />
この中で、たとえば合計が<var>4</var>になるのは<br />
<samp xml:lang="en">(1, 3), (2, 2), (3, 1)</samp><br />
の３通り。樹形図を書かせれば間違えようがない。<br />
しかし樹形図を書かせなかったら<br />
<samp xml:lang="en">(1, 3), (2, 2), <em class="false">(2, 2)</em>, (3, 1)</samp><br />
のような間違いが発生する場合がある。というかむしろ最初は書かせずにこの間違いを意図的に誘発しておいてから樹形図に立ち返らせると納得させられると共に慎重さが養われるかもしれない。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1661325034673">
<section>
<h3>いわゆる<code xml:lang="en">wait(milliseconds)</code></h3>
<ul><li>ごく普通に<pre xml:lang="en"><code>import {setTimeout} from 'node:timers/promises';
await setTimeout(1000);</code></pre>特に0ミリ秒とか1ミリ秒でやりたいことを達成するには<pre xml:lang="en"><code>import {setImmediate} from 'node:timers/promises';
await setImmediate();</code></pre>が用意されている。ブラウザでは使えないし非標準だから将来的にもブラウザでは使えないかもしれないがこういうの嫌いじゃないというか割と好き。</li>
<li>2年くらい昔までなら<pre xml:lang="en"><code>await new Promise(resolve =&gt; setTimeout(resolve, 1000));</code></pre>みたいな感じかな、でも今更こんなの書かないからノイズだ。しかしブラウザだとまだまだずっとこれから先もこれを使うのかな。</li></ul>
</section>
</article>
<article id="ID_TIME_STAMP_1661070577093">
<section>
<h3>今月<span xml:lang="en">macOS</span>を<samp xml:lang="en">12.5.1</samp>に更新してから</h3>
<p><span xml:lang="en">Safari</span>でローカルファイルを開くと<abbr xml:lang="en" title="cross-origin resource sharing">CORS</abbr>エラーが出るようになったのかな？</p>
<p>急速に不便になっていっている。ネットって、15年前、いや、20年前くらいが楽しさ便利さのピークだったな。もし自分が30年遅く生まれていてもやはりネット周辺のプログラミングには嵌ったに違いないだろうと思うが、大して上達しないだろうと思う、何故ならあまり楽しくないから。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1660688839928">
<section>
<h3>ルーチンワークで解ける漸化式を惰性で解いてしまったら</h3>
<p>誤差はどこら辺で出るのか試してみた。</p>
<p xml:lang="en"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo></math><br />
<math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>F</mi><mn>2</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo></math><br />
<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>F</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>F</mi><mi>n</mi></msub><mo>+</mo><mn>1</mn></mrow><mo>,</mo><mrow><mo>&forall;</mo><mi>n</mi><mo>&isin;</mo><mi mathvariant="double-struck">N</mi></mrow></math></p>
<ul><li>そのまま翻訳して<br />
<code xml:lang="en">const f = (F =&gt; n =&gt; n &lt; 3 ? 0 : (F[n - 2] ?? (F[n - 2] = f(n - 2))) + (F[n - 1] ?? (F[n - 1] = f(n - 1))) + 1)({});</code><br />
を得る。これは正解を返す。</li>
<li>うっかりやってしまった解答からは
<pre xml:lang="en"><code>function φ(n) {
    const n_2 = n - 2;
    if (n_2 &lt;= 0) {
        return 0;
    }
    const sqrt5 = Math.sqrt(5);
    return Number((((3 + sqrt5) / 2 * ((1 + sqrt5) / 2) ** n_2 - (3 - sqrt5) / 2 * ((1 - sqrt5) / 2) ** n_2) / sqrt5 - 1).toFixed(0));
}</code></pre>
を得る。これは<code xml:lang="en">Math.sqrt(5)</code>の誤差が<var xml:lang="en">n</var>の増加で展開的に増加する。</li></ul>
<pre xml:lang="en"><code>for (let i = 1; i &lt;= Number.MAX_SAFE_INTEGER; i++) {
    const φi = φ(i);
    const fi = f(i);
    // console.log({i, φi, fi, eq: φi == fi});
    if (φi != fi) {
        console.log(i - 1);
        break;
    }
}</code></pre>
<p><samp xml:lang="en">70</samp>だった。面倒なので考察無しの結果まで。終了。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1659801258913">
<section>
<h3>新たにプログラミング言語を学習する時に</h3>
<p>作る何かは人それぞれかなと思われる。ネットを見てきた記憶では<abbr xml:lang="en" title="hypertext transfer protocol">HTTP</abbr>サーバー/クライアントを作るとか簡単な<abbr xml:lang="en" title="world internet knowledge index">wiki</abbr>を作るとかが割と多いかなと思うが、見ず知らずのみなさんの学習が速くてその高い能力に舌をまく。</p>
<p>まるで他人事のように言うと私はいつも順列か数独ソルバーを書くようで、いずれにせよ樹形図を脳内に描いてそれをコードにする作業となる。学習しているわけではないくせに手持ち無沙汰だったので何気に順列を書いてみた。</p>
<ol>
<li><p>私にはまず樹形図を<em>探索するような</em>コードを書いてしまう悪い傾向・癖がある。それはもう書く前から<samp xml:lang="en">RangeError: Maximum call stack size exceeded</samp>になるの分かっていても書いてしまう。</p>
<pre xml:lang="en"><code>async function * P_indices_search(m, n, ...indices) {
    switch (indices.length) {
        case 0: {
            yield * P_indices_search(m, n || m, 0);
            break;
        }
        case n || m: {
            yield indices.slice(0);
            let i = indices.pop() + 1;
            while (true) {
                if (indices.includes(i)) {
                    i += 1;
                } else if (i == m) {
                    if (indices.length == 0) {
                        return;
                    } else {
                        i = indices.pop() + 1;
                    }
                } else {
                    break;
                }
            }
            yield * P_indices_search(m, n || m, ...indices, i);
            break;
        }
        default: {
            for (let i = 0; i &lt; m; i++) {
                if (indices.includes(i)) {
                    continue;
                } else {
                    yield * P_indices_search(m, n || m, ...indices, i);
                    break;// for
                }
            }
            break;
        }
    }
}</code></pre>
<p>案の定、使えなかった。6の階乗が精一杯だった。</p></li>
<li><p>頭を切り替えて<em>なるべくフラットに</em>書いてみた。</p>
<pre xml:lang="en"><code>async function * P_indices_semiFlat(m, n) {
    if (n == undefined || Number.isNaN(n)) {
        n = m;
    }
    if (n == 1) {
        for (let i = 0; i &lt; m; i++) {
            yield [i];
        }
    } else {
        for await (const p of P_indices_semiFlat(m, n - 1)) {
            for (let i = 0; i &lt; m; i++) {
                if (!p.includes(i)) {
                    yield [...p, i];
                }
            }
        }
    }
}</code></pre>
<p>10の階乗(3_628_800)ぶんすべてを出力させたら問題無く完遂した。しかし遅い。</p></li>
<li><p><em>再帰を消してみる。</em><span xml:lang="en">python</span>で言うと<var xml:lang="en">itertools.product()</var>からフィルターすることで<var xml:lang="en">itertools.permutations()</var>を作る。</p>
<pre xml:lang="en"><code>
async function * P_indices(m, n) {
    const J = n || m;
    const I = m ** J;
    for (let i = 0; i &lt; I; i++) {
        const dps = [];
        for (let j = i; dps.unshift(j % m) &lt; J; j = Number.parseInt(j / m));
        if (new Set(dps).size == dps.length) {
            yield dps;
        }
    }
}</code></pre>
<p>まあ一先ずはこれで良い。というか暇潰しなので良いも糞も無いが。</p></li>
</ol>
<p>とりあえず試してみた。</p>
<pre xml:lang="en"><code>async function * P(a, n_of_<sub>m</sub>P<sub>n</sub>) {
    const A = Array.from(a);
    for await (const p_indices of P_indices(A.length, n_of_<sub>m</sub>P<sub>n</sub>)) {
        yield p_indices.map(i =&gt; A[i]);
    }
}
for await (const p of P(process.argv.slice(2))) {
    console.log(p);
}</code>

<samp>$ </samp><kbd>node permutation.js a b c
</kbd><samp>[ 'a', 'b', 'c' ]
[ 'a', 'c', 'b' ]
[ 'b', 'a', 'c' ]
[ 'b', 'c', 'a' ]
[ 'c', 'a', 'b' ]
[ 'c', 'b', 'a' ]</samp></pre>
<p>なんか虚しい。というかそもそも<var xml:lang="en">Iterator</var>は<var xml:lang="en">class</var>で書くべきなんだよな。暇潰しなので書き直さず終了。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1659544495420">
<section>
<h3><code xml:lang="en">defer</code>属性と<code xml:lang="en">async</code>属性をそれぞれ指定した2つの<code xml:lang="en">&lt;SCRIPT&gt;</code>要素で読み込んだ内容が</h3>
<p><span xml:lang="en">defer</span>→<span xml:lang="en">async</span>の順に実行される。スクリプト内容は全く同じ<code xml:lang="en">console.log('...')</code>だけで、しかも<span xml:lang="en">async</span>属性有りを<abbr xml:lang="en">HTML</abbr>ソース出現順序で先に書いているのに、このように<span xml:lang="en">defer</span>が先になる。本来はスクリプト要素オブジェクトの<var xml:lang="en">load</var>時に<em>非同期実行</em>が始まるのとドキュメントオブジェクトの<var xml:lang="en">DOMContentLoaded</var>時に<em>実行</em>が始まる違いがあるわけで、しかも<abbr xml:lang="en">HTML</abbr>ソース出現順によって読み込み開始は<span xml:lang="en">async</span>有りの方が先になる。更にはスクリプト内容と<abbr xml:lang="en">HTML</abbr>ソースに量的大差をつけていて、これがそのまま実行順序に大きく影響するとふつうは考えられるが、現実の結果は逆。<em><code xml:lang="en">async</code>後回しの法則</em>だな笑。</p>
<p>たとえば<span xml:lang="en">Node.js</span>の<var xml:lang="en">HTTP</var>モジュールのドキュメントみたいに時系列のイベント詳細が欲しい。各自で実験してみてブラックボックスを探るなんてナンセンスだよな。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1659456883285">
<section>
<h3>中1夏休み宿題を</h3>
<p>目の前でやっていた。どうやら今の過程では素数と素因数分解を中学の最初に習うらしい。おもむろに<abbr title="macbook pro" xml:lang="en">MBP</abbr>を開いて</p>
<pre xml:lang="en"><code>function toPFD(m) {
    const ps = [];
    const o = 'o';
    const r = new RegExp(&#96;^(${o.repeat(2)}+?)\\1+\$&#96;);
    let s = o.repeat(m);
    for (let match = s.match(r); match; match = s.match(r)) {
        ps.push(match[1].length);
        s = o.repeat(Number((s.length / match[1].length).toFixed(0)));
    }
    ps.push(s.length);
    return ps;
}
function isPrime(m) {
    return m == 1 ? false : toPFD(m).length == 1;
}</code></pre>
<p>と書いて答え合わせしてやったらえらく感動された。どうやら今時の子どもはプログラムを書ける人を凄いと思うらしい。</p>
<p>これは<span xml:lang="en">perl cookbook</span>で読んで20年ほど前から使わせてもらっているから純然たる暗記の反芻でしかないわけだがと内心苦笑した。本来は素数判定が先んじるべきだがこの正規表現応用が記憶に染み付いてしまっている。</p>
<p><code xml:lang="en">[@@matchAll]</code>で一行再帰で書けないかと少しやってみたがかなり汚くなるので止めた。その過程で</p>
<pre xml:lang="en"><samp>&gt; </samp><kbd>r = /^(oo+?)\1+$/g;
</kbd><samp>/^(oo+?)\1+$/g
&gt; </samp><kbd>Array.from('o'.repeat(100).matchAll(r))<strong>.flatMap</strong>(([_0, _1]) =&gt; _0 ? _0.length / _1.length : 1);
</kbd><samp>[ 50 ]
&gt; </samp><kbd>Array.from('o'.repeat(100).matchAll(r))<strong>.map</strong>(([_0, _1]) =&gt; _0 ? _0.length / _1.length : 1);
</kbd><samp>[ 50 ]</samp></pre>
<p>のように<var xml:lang="en">Array#flatMap()</var>と<var xml:lang="en">Array#map()</var>が結果同じになるという事例に遭遇した。当たり前ではあるものの、無意味に<var xml:lang="en">Array#flatMap()</var>を使って気づいていない場合があるかもしれない。</p>
<ins datetime="2022-08-02T18:07:00Z"><p>やっぱり<span xml:lang="en">Google Chrome</span>の&lt;pre&gt;要素のスタイルが変。空白文字を独自の扱いしてんのかな。今の仕様が『<a href="https://drafts.csswg.org/css-text/#white-space-property" hreflang="en" xml:lang="en">3. White Space and Wrapping: the white-space property</a>』であるとして、どの値にも該当しない扱いで空白文字を処理している。もしかしたら<a href="https://drafts.csswg.org/css-text/#valdef-white-space-nowrap" hreflang="en" xml:lang="en"><var>nowrap</var></a>の空白文字扱いにある<q cite="https://drafts.csswg.org/css-text/#valdef-white-space-nowrap" xml:lang="en">Like <var>normal</var>, this value collapses white space;</q>だけを切り取り読みして空白文字のまとめ方を自分ルールでやっちゃったのかな？しかしこの<span xml:lang="en">Like <a href="https://drafts.csswg.org/css-text/#valdef-white-space-normal" hreflang="en"><var>normal</var></a></span>は<q cite="https://drafts.csswg.org/css-text/#valdef-white-space-normal" xml:lang="en">This value directs user agents to collapse sequences of white space into <em>a single</em> character (or in some cases, <em>no character</em>).</q>に倣うようにと解釈するのが自然だと思うけどな。</p>
<p>(もちろん言うまでもなくこのブラウザデフォルト値の<a href="https://drafts.csswg.org/css-text/#valdef-white-space-pre" hreflang="en" xml:lang="en"><var>pre</var></a>に然るべき表示ではないわけで……。)</p></ins>
</section>
</article>
<article id="ID_TIME_STAMP_1659205390735">
<section>
<h3><code xml:lang="en">0 &lt; n &lt; Number.EPSILON</code>と誤記して暫く気付かなかった。</h3>
<p>以下の通り。</p>
<pre xml:lang="en"><samp>&gt; </samp><kbd>Number(true)
</kbd><samp>1
&gt; </samp><kbd>Number(false)
</kbd><samp>0
&gt; </samp><kbd>true &lt; .2
</kbd><samp>false
&gt; </samp><kbd>true &lt; 1.2
</kbd><samp>true
&gt; </samp><kbd>0 &lt; .1
</kbd><samp>true
&gt; </samp><kbd>.1 &lt; .2
</kbd><samp>true
&gt; </samp><kbd>0 &lt; .1 &lt; .2 // Number(0 &lt; .1) &lt; .2
</kbd><samp><strong>false</strong>
&gt; </samp><kbd>1 &lt; 1.1
</kbd><samp>true
&gt; </samp><kbd>1.1 &lt; 1.2
</kbd><samp>true
&gt; </samp><kbd>1 &lt; 1.1 &lt; 1.2 // Number(1 &lt; 1.1) &lt; 1.2
</kbd><samp><strong>true</strong></samp></pre>
</section>
</article>
<article id="ID_TIME_STAMP_1659033675876">
<section>
<h3><span xml:lang="en">mariadb</span>用に<span xml:lang="en">.cnf, .ini</span>パーサーを書いたら</h3>
<p>時間かかり過ぎて凹んだ。脳の加齢は万人に平等、辛いねえ。</p>
<p>そもそもどういうものだと自分に使い易いかを考えて、<span xml:lang="en">python</span>の<span xml:lang="en">configparser</span>を使い慣れていたかなと思って検索したらそのものズバリがあったので使っていた。もちろん<code xml:lang="en">extends</code>して自分好みにして使っていたが、やっぱり依存をできる限り消したいのと、このくらいはサクッと書けよ自分と思いつつも、常識的に考えてそんな車輪のなんちゃらは不要なはずだから放置していた。</p>
<p>まあ、サクッとどころかダラダラながらいちおう形になったから差し替えた。<code xml:lang="en">readline.on('close', resolve)</code>しているので<code xml:lang="en">constructor</code>直下で呼べなくなった笑。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658947366442">
<section>
<h3><span xml:lang="en">Docker</span>が更新しろしろと面倒くさい。</h3>
<p>使わんし。こういう仮想化環境の類は流行を垣間見る為だけの目的でかれこれ15年くらいインストールだけして放置しているが、これほどウザいのは初だな。いわゆる<abbr title="system integrator" xml:lang="en">SIer</abbr>がかなり積極的に仮想化環境を推してきていたのがリーマンショックの頃だったかな、当時予算が厳しい企業に対してリプレイスのコストにおけるメリットを強弁しつつの営業戦略だったように記憶している。要するに良いイメージが全く無いという笑。その直後あたりから本屋に個人向け仮想化環境の実用書が爆増した。</p>
<p>好き嫌いとは別に、ホンマに使わんのよね。個人的には20年以上前からえっちらおっちら<span xml:lang="en">FreeBSD</span>や<span xml:lang="en">Linux</span>をインストールして使っているし<abbr title="virtual private network" xml:lang="en">VPN</abbr>や<abbr title="internet protocol security" xml:lang="en">IPSec</abbr>でリモート作業し続けてきたわけで、2010年代以降の簡単便利になった時代に今更のように態々あえて仮想化環境で<span xml:lang="en">Linux</span>するモチベーションが無い。</p>
<p>しかし<span xml:lang="en">venv</span>くらいは使うわけだが、こういう簡素で大人しいのだけでいいよ。<span xml:lang="en">Docker</span>ホンマにウザい。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658866439019">
<section>
<h3>体感的に昨日がいちばん暑かった</h3>
<p>ような気がする。暑いとなぜか<abbr title="バッティングセンター">バッセン</abbr>に行きたくなるが、肩が痛くて両手で構えられないから無理だな。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658761657237">
<section>
<h3>有理数の稠密性って</h3>
<p>定期試験にすら出ないよな。ごくごく一部の人を除けば、前の世代から教わる時か次の世代に教える時に思考するだけ。ならばその説明は教示的であるべきだと思われる。</p>
<p>ネット検索すると判で押したように
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mfrac><mn>1</mn><mrow><mi>y</mi><mo>-</mo><mi>x</mi></mrow></mfrac><mo>&lt;</mo><mi>n</mi></math>
がいきなり出てくるが、ここに至るまでを教示的にモタモタ説明すると、まず、中高生は有理数と聞くと脊髄反射的にそれを
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mfrac><mi>m</mi><mi>n</mi></mfrac></math>
とすることから始めるわけで、ほとんどの子はここでピタリと筆が止まるわけだが、比較的できる子が、
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mi>x</mi><mo>&lt;</mo><mfrac><mi>m</mi><mi>n</mi></mfrac><mo>&lt;</mo><mi>y</mi></math>
を証明しようとし始める。すなわち、
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mi>n</mi><mo>&InvisibleTimes;</mo><mi>x</mi><mo>&lt;</mo><mi>m</mi><mo>&lt;</mo><mi>n</mi><mo>&InvisibleTimes;</mo><mi>y</mi></math>
を証明するわけだが、ここで比較的出来る子の大半がピタリと筆が止まって、残った優秀な子らが、幅が大きければ何らかの正整数は入るよなと気付き、言うなれば整数の幅1を半ば経験的に使おうとするわけ。つまり、
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mi>n</mi><mo>&InvisibleTimes;</mo><mi>y</mi><mo>-</mo><mi>n</mi><mo>&InvisibleTimes;</mo><mi>x</mi><mo>&gt;</mo><mn>1</mn></math>
となる
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mi>n</mi></math>
は存在するから云々、で、証明を終える。極々一部の余裕がある子たちだけが、
<math xmlns="http://www.w3.org/1998/Math/MathML" xml:lang="en"><mfrac><mn>1</mn><mrow><mi>y</mi><mo>-</mo><mi>x</mi></mrow></mfrac><mo>&lt;</mo><mi>n</mi></math>
と変形して、いくらでも大きい自然数は存在するからという公理に基づいた分かり易い説明に至るわけだ。</p>
<p>まぁ、ほぼ全滅的にコピペなんだろうけど……。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658696413455">
<section>
<h3><code xml:lang="en">console.histogram()</code>みたいなのが</h3>
<p>欲しい。<code xml:lang="en">console.table()</code>と同様の引数で綺麗にターミナル上にヒストグラムを描画してくれるようなの。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658692061092">
<section>
<h3>今更ながら<code xml:lang="en">Promise</code>の解説ページの殆どは</h3>
<p>不慣れな入門者が書いている笑。そんなもん書いていないで実験しまくれよとしか笑。</p>
<p>とりあえず知りたいのって次の5つじゃないか？</p>
<ul>
<li>非同期処理は<em>実際のところ</em>処理の後回し。後から理想的に同時スタートっぽくなるとしたら、そもそも非同期にしなくても十分高速に回るというのが現実かなと思う。</li>
<li>コンストラクタの引数は関数。それの<span xml:lang="en"><var>resolve</var>, <var>reject</var></span>という名前の仮引数は内部の目印。共に関数扱いされるし関数扱いすること。また、必ずしもこの名前である必要がないというか<a href="#ID_TIME_STAMP_1657555918594">名前すら不要</a>。<ul>
<li><code xml:lang="en">resolve()</code>は<code xml:lang="en">return</code>にかなり似ている。違いは<code xml:lang="en">resolve()</code>より後に続くコードも実行される。</li>
<li><code xml:lang="en">reject()</code>は<code xml:lang="en">throw</code>にかなり似ている。違いは<code xml:lang="en">reject()</code>より後に続くコードも実行される。</li>
</ul></li>
<li><span xml:lang="en"><code>.then()</code>, <code>.catch()</code>, <code>.finally()</code></span>はチェーン順に処理される。これが<span xml:lang="en"><code>try {} catch {} finally {}</code>, <code>try {} finally {}</code></span>のように順序が決まっている書き方との違い。</li>
</ul>
</section>
</article>
<article id="ID_TIME_STAMP_1658383702668">
<section>
<h3>『いきなり<code xml:lang="en">.then()</code>』</h3>
<p>は必要かなと思う。どういうことかと言うと<code xml:lang="en">new Class().method().then()</code>の<code xml:lang="en">.method()</code>を忘れても大丈夫なように作っておいても悪くはないだろうと思う。</p>
<p>例えば<code xml:lang="en">new TXNs(...).fetch().then(...)</code>の<code xml:lang="en">.fetch()</code>みたいな常に呼ばれるに決まっているであろうメソッドのこと。</p>
<ins datetime="2022-07-29T15:56:19Z"><p>必ず<code xml:lang="en"><em>async</em> then(cb) {...}</code>みたいに<code xml:lang="en">async</code>を明示して定義すること。じゃないと<code xml:lang="en">.catch()</code>をチェーンしても無意味になる。</p></ins>
</section>
</article>
<article id="ID_TIME_STAMP_1658252007112">
<section>
<h3>ミリ秒</h3>
<p><span xml:lang="en">mariadb</span>でいわゆる<span xml:lang="en">unix time</span>を<var>13</var>桁の<code xml:lang="en">BIGINT</code>にしている。これを<span xml:lang="en">node-mariadb</span>で読むとデフォルトで<code xml:lang="en">BigInt</code>になる。</p>
<p>原因を調べていないが</p>
<ul xml:lang="en">
<li><code>.map(record => new Proxy(record, {get: (t, p, r) =&gt; p == 'foo' ? Number(t[p]) : Reflect.get(t, p, r)}))</code></li>
</ul>
<p>みたいなのがスルーされる。これ自体をあるひとつのオブジェクトに対してテストしたら意図通りになるので、数万レコード以上という数が問題なのかなと思われる。追求する時間がアホらしいので</p>
<ul xml:lang="en">
<li><code>.map(({foo, bar}) => ({foo: Number(foo), bar}))</code></li>
</ul>
<p>のような処理にした(もちろん意図通りの値を返す)。</p>
<p>もし<code xml:lang="en">BIGINT</code>がこの<var xml:lang="en">timeStamp</var>だけなら、<code xml:lang="en"><var>bigIntAsNumber</var>: true</code>みたいにオプションを適切に設定すれば良いだけだが、他にも<code xml:lang="en">BIGINT</code>はあるから却下だな。</p>
<ins datetime="2022-07-24T13:46:12Z"><p>もしかしたら<br />
<code xml:lang="en">const entries = [['20220719', {usd_jpy: 137.908}], ['20220724', {usd_jpy: 136.136}]];<br />
console.table(entries);<br />
console.table(Object.fromEntries(entries));<br />
const entries_proxied = entries.map(([u, v]) =&gt; [u, new Proxy(v, {get: (t, p, r) =&gt; p == 'usd_jpy' ? <strong>Math.floor(t[p])</strong> : Reflect.get(t, p, r)})]);<br />
console.table(entries_proxied);<br />
console.table(Object.fromEntries(entries_proxied));</code><br />
の出力で</p>
<table xml:lang="en">
<caption><kbd>entries</kbd></caption>
<colgroup span="1"><col /></colgroup><colgroup span="2"><col /><col /></colgroup>
<thead><tr><th><samp>(index)</samp></th><th><samp>0</samp></th><th><samp>1</samp></th></tr></thead>
<tbody>
<tr><th><samp>0</samp></th><td><samp>'20220719'</samp></td><td><samp>{ usd_jpy: 137.908 }</samp></td></tr>
<tr><th><samp>1</samp></th><td><samp>'20220724'</samp></td><td><samp>{ usd_jpy: 136.136 }</samp></td></tr>
</tbody></table>
<table xml:lang="en">
<caption><kbd>Object.fromEntries(entries)</kbd></caption>
<colgroup span="1"><col /></colgroup><colgroup span="1"><col /></colgroup>
<thead><tr><th><samp>(index)</samp></th><th><samp>usd_jpy</samp></th></tr></thead>
<tbody>
<tr><td><samp>20220719</samp></td><td><samp>137.908</samp></td></tr>
<tr><td><samp>20220724</samp></td><td><samp>136.136</samp></td></tr>
</tbody></table>
<table xml:lang="en">
<caption><kbd>entries_proxied</kbd></caption>
<colgroup span="1"><col /></colgroup><colgroup span="2"><col /><col /></colgroup>
<thead><tr><th><samp>(index)</samp></th><th><samp>0</samp></th><th><samp>1</samp></th></tr></thead>
<tbody>
<tr><th><samp>0</samp></th><td><samp>'20220719'</samp></td><td><samp>{ usd_jpy: 137.908 }</samp></td></tr>
<tr><th><samp>1</samp></th><td><samp>'20220724'</samp></td><td><samp>{ usd_jpy: 136.136 }</samp></td></tr>
</tbody></table>
<table xml:lang="en">
<caption><kbd>Object.fromEntries(entries_proxied)</kbd></caption>
<colgroup span="1"><col /></colgroup><colgroup span="1"><col /></colgroup>
<thead><tr><th><samp>(index)</samp></th><th><samp>usd_jpy</samp></th></tr></thead>
<tbody>
<tr><td><samp>20220719</samp></td><td><samp><strong>137</strong></samp></td></tr>
<tr><td><samp>20220724</samp></td><td><samp><strong>136</strong></samp></td></tr>
</tbody></table>
<p>みたいに違ってくることが関係しているかもな。<em>浅いと結果的に見て<code xml:lang="en">[[Get]]</code>が呼ばれていないことになっている。</em></p></ins>
<p>というか<abbr title="javascript object notation" xml:lang="en">JSON</abbr>や<abbr title="comma separated values" xml:lang="en">CSV</abbr>からの集計などで『<abbr title="structured query language" xml:lang="en">SQL</abbr>使えば楽だな』と思えば迷わず<code xml:lang="en">[TEMPORARY] TABLE</code>からの丸投げに限る。</p>
<ins datetime="2022-07-24T14:58:33Z"><p>しかしあれだな、<span xml:lang="en">Google Chrome</span>は<code xml:lang="en">&lt;pre&gt;</code>要素をこちらの意図通りにはレンダリングしないのな。イラッとさせられたので<code xml:lang="en">&lt;table&gt;</code>要素でマークアップした。</p></ins>
</section>
</article>
<article id="ID_TIME_STAMP_1658250573834">
<section>
<h3>肩関節周囲炎</h3>
<p>が激痛になってから3ヶ月にもなる。ネットで軽く検索する限りではこれほどの重症例が無い。こうすれば楽ですよ的な姿勢をそもそも取れないほど酷い。精神的にも病むような気がする。渡された薬は鎮痛薬ばかり。知識は無いが何のメリットも無いように思われる。</p>
<p>5年半ほど前に左肩に症状が出た。自分が突然老け込んだような気持ちになった。凡そ3年で懸垂出来るまでに回復した。その経験から右肩を殊更に大事にしていたつもりだったが、半年前くらいから嫌な違和感が出始めて春に一気に重症化した。</p>
<p>加齢が最大の原因なのかもしれないが、10年前くらいから毎日真面目に懸垂をやり続けたのが悪かったかなとも考えている。背中がボコボコになっていくのは楽しかったが関節にはよろしくなかったのではないかと。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658064666464">
<section>
<h3>山鉾巡行</h3>
<p>が終わった。梅雨明けを明示していた頃はこれの前あたりでいつも梅雨明け宣言が出ていたように記憶する。祇園祭は神事で天神祭は商業イベントだと思う。この両者は共に好きなのだが、これら以外の祭はどうも性に合わない。こう言っちゃなんだが他所のお祭りはどれも個々が勝手に動いているだけのように見劣りする。</p>
<p>個人的には送り火がいちばん好き。体力余っていた頃におそらく3桁回は登った如意ヶ嶽への愛着を抜きにしても送り火がいちばん好き。深い大気の底の暗闇から見上げる送り火の美しさ儚さは筆舌に尽くし難い。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658046084979">
<section>
<h3><code xml:lang="en">.toExponential()</code>しない限りは全部アウトプットして欲しい。</h3>
<p>適切な例が思い浮かばないが例えば</p>
<ul><li><code xml:lang="en">function sqrt(integerPortion: BigInt, fractionalPortion: BigInt): BigInt {...}</code></li></ul>
<p>みたいなのは使い勝手どうなのかな。</p>
<p>もちろん必要なのは<code xml:lang="en">BigInt#toString()</code>だからこれはそもそも<code xml:lang="en">String</code>で良い。</p>
<p>そもそも数値リテラルとして<code xml:lang="en">1.0e-20</code>は要るのかもしれないがそれが数字として<code xml:lang="en">"1.0e-20"</code>と表示されて欲しい場面はむしろ特殊だと思われるわけで、文字列は入力そのままで何百桁でも愚直に返して欲しい。例えば10進数以外の文字列は丸めた結果を長々と返すだけなんだが、こういうのも要らんのよね、愚直に入力をそのまま返して欲しい。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1658040882838">
<section>
<h3><span xml:lang="en">github</span>での編集だけで書いていたが</h3>
<p>やはり反映の遅さを我慢できなくなってローカルで書く事にした。データ(<abbr xml:lang="en">HTML</abbr>など)や設定(<abbr xml:lang="en">CSS</abbr>など)のインデントが個人的に本当に嫌いなのでこの機に全て削除した。</p>
<p>この個人的好みを正しいものと仮定して、今の世の中には明らかに間違った方向が実在する。<span xml:lang="en"><abbr title="syntactically awesome style sheets">SASS</abbr>/<abbr title="sassy css">S<abbr>CSS</abbr></abbr></span>のこと。あのね、フラットだからみんな書けるの。デザイナーが書く<span xml:lang="en">jQuery</span>見てみ、フラットで逐次的で設定ファイル的で逆に鱗落ものだから笑。それをわざわざ入れ子にさせたり抽象化の仕組みを入れてみたりと、作業する者の知能を考慮したら絶対にやっちゃいけないことのオンパレード。ひどい仕打ちだろ笑。</p>
<p>そもそも私みたいに<abbr xml:lang="en" title="netscape navigator">NN</abbr>向けに<abbr title="javascript style sheets" xml:lang="en">JSSS</abbr>をリアルタイムで普通に書いていたジジイからしたら負の遺産の再発明にしか見えないよ。というかどうしても処理手順を書きたきゃ<abbr title="javascript" xml:lang="en">JS</abbr>で<abbr title="cascading style sheets" xml:lang="en">CSS</abbr>を弄りゃ良いじゃん、今どきオフにしている人なんてギガ欠乏期の人だけだろうし。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1657903121448">
<section>
<h3>数学・算数の試験で解き方を強制されるのは</h3>
<p>院試からだと思う。それまでは好きにして良いはず。</p>
<p>『未修範囲から出題してはいけない』とは大人に対する制約。それをアホな大人が勝手独自に混同して子供も未修範囲の解き方をしてはいけないと変な誤解に陥っているだけじゃないかな。正しい理解が適切に解答に示されていれば未修か既習かなんて採点者は関知しないはず。</p>
<p>というか15年くらい昔の東工大の院試に3辺が正整数で具体的に与えられた三角形の面積を求めさせる問題があって、それをヘロンの公式だかなんだかで解いても点数あるのかと疑問に思ったことがある。センター試験じゃないんだから。数値は記憶に無いが、例えば<var>12,17,25</var>みたいな、物理系工学系なら秒殺できて当然の数値だった。これをえっちらおっちら高校代数幾何で出てきたような公式で解いて点数あるとはとても思えないんだけどな。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1657832624465">
<section>
<h3>面倒くさいは老化の特徴。</h3>
<ul>
<li><p>何年も <span xml:lang="en">Windows</span>を所有していないからどうでもいいが、なんとなくトライアンドエラーでやっていた事がはっきり解った。</p>
<dl xml:lang="en">
<dt><a href="https://dev.mysql.com/doc/refman/8.0/en/option-files.html#option-file-syntax">MySQL 8.0 Reference Manual / ... / Option File Syntax</a></dt>
<dd><blockquote cite="https://dev.mysql.com/doc/refman/8.0/en/option-files.html#option-file-syntax"><p>The escaping rules for option file values are especially pertinent <em>for Windows path names</em>, which use <code>\</code> as a path name separator. A separator in a Windows path name must be written as <code>\\</code> <em>if it is followed by an escape sequence character</em>. It can be written as <code>\\</code> or <code>\</code> <em>if it is not</em>.</p></blockquote></dd>
<dt><a href="https://dev.mysql.com/doc/refman/8.0/en/option-files.html#option-file-inclusions">MySQL 8.0 Reference Manual / ... / Option File Inclusions</a></dt>
<dd><blockquote cite="https://dev.mysql.com/doc/refman/8.0/en/option-files.html#option-file-inclusions"><p>For inclusion directives to work, the file path should <em>not</em> be specified within quotes and should have <em>no</em> escape sequences.</p></blockquote></dd>
</dl></li>
<li><p>こういうの書く人には感謝するが、自分は面倒くさいから書くことはない。</p>
<dl xml:lang="en">
<dt><a href="https://mariadb.com/kb/en/configuring-mariadb-with-option-files/#option-prefixes">MariaDB Option Prefixes</a></dt>
<dd><blockquote cite="https://mariadb.com/kb/en/configuring-mariadb-with-option-files/#option-prefixes"><table><thead><tr><th>Option Prefix</th><th>Description</th></tr></thead><tbody>
<tr><td><code><a href="https://mariadb.com/kb/en/mysqld-options/#-autoset-">autoset</a></code></td><td>Sets the option value automatically. Only supported for certain options. Available in <a href="https://mariadb.com/kb/en/mariadb-1017-release-notes/">MariaDB 10.1.7</a> and later.</td></tr>
<tr><td><code><a href="https://mariadb.com/kb/en/mysqld-options/#-disable-">disable</a></code></td><td>For all boolean options, disables the setting (equivalent to setting it to <code>0</code>). Same as <code>skip</code>.</td></tr>
<tr><td><code><a href="https://mariadb.com/kb/en/mysqld-options/#-enable-">enable</a></code></td><td>For all boolean options, enables the setting (equivalent to setting it to <code>1</code>).</td></tr>
<tr><td><code><a href="https://mariadb.com/kb/en/mysqld-options/#-loose-">loose</a></code></td><td>Don't produce an error if the option doesn't exist.</td></tr>
<tr><td><code><a href="https://mariadb.com/kb/en/mysqld-options/#-maximum-">maximum</a></code></td><td>Sets the maximum value for the option.</td></tr>
<tr><td><code><a href="https://mariadb.com/kb/en/mysqld-options/#-skip-">skip</a></code></td><td>For all boolean options, disables the setting (equivalent to setting it to <code>0</code>). Same as <code>disable</code>.</td></tr>
</tbody></table></blockquote></dd>
</dl></li>
</ul>
</section>
</article>
<article id="ID_TIME_STAMP_1657690077205">
<section>
<h3>運転中に画面をじっと見るのが危ないのと同様に</h3>
<p>標識等をじっと見るのも危ないな。見て情報を得ることと検討することを意識して分離しなければ危ない。見ながら考えていると気付かぬうちに何秒も経過しているわけだが、交通事故はその何秒かで十分起こり得る。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1657555918594">
<section>
<h3>いささかトリッキーな感じだが</h3>
<code xml:lang="en">new Promise((form =&gt; form.addEventListener.bind(form, 'submit'))(document.forms.namedItem('...')))<br />
.then(e =&gt; {...; return e}).then(e =&gt; {...; return e})....catch(error => {...})/*.finally(...)*/;</code><br />
は最初のイベント発生時に実行されるだけ。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1657475163538">
<section>
<h3>損切りしなくて済む条件はごく単純に</h3>
<ul>
<li>いつか必ず戻り、かつ、</li>
<li>いつまででも待てる。</li>
</ul>
<p>だろうと思われるが、検索すると判を押したかのように損失金額を条件というか事前に決意したそれに従えみたいな事が書かれている。時間を金額に当たり前のように飛躍させる気持ちは分からなくはないが、そこに数理が無ければそれはオカルトでしかない。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1657462591703">
<section>
<h3>好きに<abbr title="hypertext markup language" xml:lang="en">HTML</abbr>を書く。</h3>
<p>それなりに楽しいが不安になる。</p>
<p>知的に高度に構築されつつあったものが悉く現実に拒絶された後の祭状態やな。</p>
</section>
</article>
<article id="ID_TIME_STAMP_1657438900634">
<section>
<h3>古い家の中は</h3>
<p>夏野菜を揚げる匂い。</p>
</section>
</article>
</body>
</html>
